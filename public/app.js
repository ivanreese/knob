// Generated by CoffeeScript 1.7.1

/*
--------------------------------------------
     Begin prototypes.coffee
--------------------------------------------
 */

(function() {
  var DEG, RAD, TAU, accumulated, activeCenter, angleToActiveCenter, canvas, center, centerTransitionTime, computePosition, computeSquareness, computedValue, computedValueIncrement, current, delta, dragging, draw, drawComputedValue, drawPoint, drawRecent, drawRecentAngle, drawRecentBounds, g, hud, hudPoint, hudValue, last, newPoint, prepareToDraw, recent, recentAngleBasis, recentCenter, recentMax, recentMin, recentSize, resize, squareness, start, time, update, usage;

  Array.prototype.sum = function() {
    if (!(this.length > 0)) {
      return 0;
    }
    return this.reduce(function(a, b) {
      return a + b;
    });
  };

  Array.prototype.average = function() {
    var total;
    if (!(this.length > 0)) {
      return 0;
    }
    total = this.reduce(function(a, b) {
      return a + b;
    });
    return total / this.length;
  };

  Array.prototype.mapPairs = function(call) {
    var values;
    if (!(this.length > 1)) {
      return [];
    }
    values = [];
    this.reduce(function(a, b) {
      values.push(call(a, b));
      return b;
    });
    return values;
  };


  /*
  --------------------------------------------
       Begin angle.coffee
  --------------------------------------------
   */

  this.Angle = {
    wrap: function(ang, bias) {
      while (bias - ang > +Math.PI) {
        ang += TAU;
      }
      while (bias - ang < -Math.PI) {
        ang -= TAU;
      }
      return ang;
    }
  };


  /*
  --------------------------------------------
       Begin vector.coffee
  --------------------------------------------
   */

  this.Vec = {
    diff: function(a, b) {
      return {
        x: b.x - a.x,
        y: b.y - a.y
      };
    },
    angle: function(a, b) {
      var p;
      p = Vec.diff(a, b);
      return Math.atan2(p.y, p.x);
    },
    distance: function(a, b) {
      var p;
      p = Vec.diff(a, b);
      return Math.sqrt(p.x * p.x + p.y * p.y);
    },
    pathLength: function(arr) {
      return arr.mapPairs(Vec.distance).sum();
    },
    lerp: function(a, b, t) {
      var d;
      d = Math.max(0, Math.min(1, t));
      return {
        x: a.x * (1 - d) + b.x * d,
        y: a.y * (1 - d) + b.y * d
      };
    }
  };


  /*
  --------------------------------------------
       Begin app.coffee
  --------------------------------------------
   */

  TAU = 2 * Math.PI;

  DEG = 180 / Math.PI;

  RAD = Math.PI / 180;

  newPoint = function() {
    return {
      x: 0,
      y: 0,
      a: 0
    };
  };

  start = newPoint();

  last = newPoint();

  current = newPoint();

  center = newPoint();

  recentCenter = newPoint();

  accumulated = newPoint();

  recentMin = newPoint();

  recentMax = newPoint();

  recentSize = newPoint();

  activeCenter = newPoint();

  usage = newPoint();

  delta = newPoint();

  centerTransitionTime = 100;

  recentAngleBasis = 0;

  recent = [
    {
      x: 0,
      y: 0
    }
  ];

  dragging = false;

  computedValue = 0;

  squareness = 0;

  time = 0;

  hud = {
    left: 30,
    labelLeft: 60,
    top: 40,
    space: 50,
    pos: 0,
    nextPos: function() {
      return hud.pos++;
    },
    resetPos: function() {
      return hud.pos = 0;
    }
  };

  canvas = null;

  g = null;

  $(function() {
    canvas = document.getElementById("canvas");
    g = canvas.getContext("2d");
    return resize();
  });

  resize = function() {
    canvas.width = $(window).width();
    canvas.height = $(window).height();
    center = {
      x: canvas.width / 2,
      y: canvas.height / 2
    };
    return draw();
  };

  $(window).on("resize", resize);

  update = function(p) {
    if (!(Vec.distance(p, last) > 0)) {
      return;
    }
    current = p;
    recent.unshift(current);
    while (Vec.pathLength(recent) > 2 * TAU * Vec.distance(activeCenter, current) && recent.length > 2) {
      recent.pop();
    }
    recentMin = recent.reduce(function(a, b) {
      return {
        x: Math.min(a.x, b.x),
        y: Math.min(a.y, b.y)
      };
    });
    recentMax = recent.reduce(function(a, b) {
      return {
        x: Math.max(a.x, b.x),
        y: Math.max(a.y, b.y)
      };
    });
    recentSize = Vec.diff(recentMin, recentMax);
    recentCenter = {
      x: (recentMin.x + recentMax.x) / 2,
      y: (recentMin.y + recentMax.y) / 2
    };
    time++;
    activeCenter = Vec.lerp(center, recentCenter, time / centerTransitionTime);
    delta = {
      x: current.x - start.x,
      y: current.y - start.y,
      a: angleToActiveCenter(current)
    };
    accumulated.x += current.x - last.x;
    accumulated.y += current.y - last.y;
    accumulated.a += Angle.wrap(current.a - last.a, 0);
    computedValue += computedValueIncrement();
    squareness = computeSquareness(recentSize);
    last = current;
    return draw();
  };

  computedValueIncrement = function() {
    var cardinalBias, preferAngularInput, useAngularInput;
    cardinalBias = 10;
    preferAngularInput = usage.a > (cardinalBias + usage.x + usage.y) * 2;
    useAngularInput = squareness > 0 || preferAngularInput;
    if (useAngularInput) {
      usage.a++;
      return Angle.wrap(current.a - last.a, 0) / TAU;
    } else if (recentSize.x > recentSize.y) {
      usage.x++;
      return (current.x - last.x) / (TAU * 20);
    } else {
      usage.y++;
      return -(current.y - last.y) / (TAU * 20);
    }
  };

  $(window).mousedown(function(e) {
    dragging = true;
    time = 0;
    recent = [];
    usage = newPoint();
    activeCenter = center;
    return start = last = computePosition(e.pageX, e.pageY);
  });

  $(window).mouseup(function(e) {
    return dragging = false;
  });

  $(window).mousemove(function(e) {
    if (dragging) {
      return update(computePosition(e.pageX, e.pageY));
    }
  });

  angleToActiveCenter = function(p) {
    var d;
    d = Vec.diff(activeCenter, p);
    return Math.atan2(d.y, d.x);
  };

  computePosition = function(x, y) {
    var p;
    p = {
      x: x,
      y: y
    };
    p.a = angleToActiveCenter(p);
    return p;
  };

  computeSquareness = function(vec) {
    return 1 - Math.abs(Math.log(vec.x / vec.y));
  };

  prepareToDraw = function() {
    hud.resetPos();
    g.clearRect(0, 0, canvas.width, canvas.height);
    g.font = "20px sans-serif";
    return g.beginPath();
  };

  drawPoint = function(p, style, size) {
    if (size == null) {
      size = 5;
    }
    g.beginPath();
    g.fillStyle = style;
    g.arc(p.x, p.y, size, 0, TAU);
    return g.fill();
  };

  drawRecent = function() {
    var p, _i, _len;
    g.beginPath();
    g.strokeStyle = "#FFF";
    g.moveTo(current.x, current.y);
    for (_i = 0, _len = recent.length; _i < _len; _i++) {
      p = recent[_i];
      g.lineTo(p.x, p.y);
    }
    return g.stroke();
  };

  drawRecentBounds = function() {
    g.beginPath();
    g.strokeStyle = "#F00";
    return g.strokeRect(recentMin.x, recentMin.y, recentSize.x, recentSize.y);
  };

  drawRecentAngle = function() {
    var angle, dx, dy, sx, sy;
    g.beginPath();
    g.strokeStyle = "#07F";
    angle = recent.mapPairs(Vec.angle).map(function(ang) {
      return Angle.wrap(ang, recentAngleBasis);
    }).average();
    recentAngleBasis = angle;
    sx = current.x;
    sy = current.y;
    dx = sx + Math.cos(angle) * 50;
    dy = sy + Math.sin(angle) * 50;
    g.moveTo(sx, sy);
    g.lineTo(dx, dy);
    return g.stroke();
  };

  drawComputedValue = function() {
    var angle, i, isNeg, loops, offset, r, _i;
    angle = computedValue * TAU;
    loops = Math.floor(Math.abs(angle) / TAU);
    isNeg = angle < 0;
    g.fillStyle = isNeg ? "rgba(255,0,0,0.2)" : "rgba(0,0,255,0.2)";
    r = 20;
    for (i = _i = 0; 0 <= loops ? _i <= loops : _i >= loops; i = 0 <= loops ? ++_i : --_i) {
      g.beginPath();
      g.arc(center.x, center.y, r * i, 0, TAU);
      g.lineTo(center.x, center.y);
      g.fill();
    }
    offset = -TAU / 4;
    angle %= TAU;
    g.beginPath();
    g.arc(center.x, center.y, r * (loops + 1), offset, angle + offset, isNeg);
    g.lineTo(center.x, center.y);
    return g.fill();
  };

  hudValue = function(value, label) {
    var pos;
    pos = hud.nextPos();
    g.fillStyle = "#F70";
    g.fillText(Math.round(value * 100) / 100, hud.left - 20, hud.top + hud.space * pos);
    g.fillStyle = "#FFF";
    return g.fillText(label, hud.left + hud.labelLeft, hud.top + hud.space * pos);
  };

  hudPoint = function(point, label, aScale) {
    if (aScale == null) {
      aScale = 1;
    }
    hudValue(point.x, "X " + label);
    hudValue(point.y, "Y " + label);
    return hudValue(point.a * aScale, "A " + label);
  };

  draw = function() {
    prepareToDraw();
    drawComputedValue();
    drawPoint(center, "#0F9");
    drawPoint(activeCenter, "#F00", 2);
    drawRecent();
    return drawRecentBounds();
  };

}).call(this);
